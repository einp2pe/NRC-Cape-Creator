class CanvasRenderer {
  private static instance: CanvasRenderer | null = null
  private templateImg: HTMLImageElement | null = null
  private templateReady = false

  static getInstance() {
    if (!CanvasRenderer.instance) CanvasRenderer.instance = new CanvasRenderer()
    return CanvasRenderer.instance
  }

  loadTemplate(src = '/nrc_cape_template.png') {
    if (this.templateImg) return
    const img = new Image()
    img.src = src
    img.onload = () => {
      this.templateImg = img
      this.templateReady = true
    }
    img.onerror = () => {
      // ignore; template optional
    }
  }

  private createGradient(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement, colors: string[], direction: 'vertical' | 'horizontal') {
    const w = canvas.width
    const h = canvas.height
    let grad: CanvasGradient
    if (direction === 'vertical') {
      grad = ctx.createLinearGradient(0, 0, 0, h)
    } else {
      grad = ctx.createLinearGradient(0, 0, w, 0)
    }
    const stops = colors.length
    colors.forEach((c, i) => {
      grad.addColorStop(stops === 1 ? 0 : i / (stops - 1), c)
    })
    return grad
  }

  // Draws cape preview. Expects canvas already scaled so logical coords match desired layout
  drawCape(
    canvas: HTMLCanvasElement,
    frontImage: HTMLImageElement | null,
    backImage: HTMLImageElement | null,
    elytraImage: HTMLImageElement | null,
    gradientColors: string[],
    gradDirection: 'vertical' | 'horizontal'
  ) {
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height)

    // Draw gradient background as preview
    const gradient = this.createGradient(ctx, canvas, gradientColors, gradDirection)
    ctx.fillStyle = gradient
    // Use CSS pixels for fill - canvas may be scaled via ctx.setTransform
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    // If template available, draw it on top for outlines
    if (this.templateReady && this.templateImg) {
      ctx.drawImage(this.templateImg, 0, 0, canvas.width, canvas.height)
    }

    // Draw images if provided; place them centered-ish
    try {
      const cw = canvas.width
      const ch = canvas.height
      const scale = 0.5
      if (backImage) {
        const w = cw * scale
        const h = ch * scale
        ctx.drawImage(backImage, cw * 0.25, ch * 0.25, w, h)
      }
      if (frontImage) {
        const w = cw * scale
        const h = ch * scale
        ctx.drawImage(frontImage, cw * 0.25, ch * 0.25, w, h)
      }
      if (elytraImage) {
        const w = cw * 0.4
        const h = ch * 0.4
        ctx.drawImage(elytraImage, cw * 0.3, ch * 0.55, w, h)
      }
    } catch (e) {
      // ignore draw errors
    }
  }
}

export default CanvasRenderer
In Zeile:1 Zeichen:291
+ ... his.templateImg) {\r\n      ctx.globalCompositeOperation = \'source-o ...
+                                                                  ~
")" fehlt in einem Methodenaufruf.
In Zeile:1 Zeichen:291
+ ... eration = \'source-over\'\r\n      ctx.drawImage(this.templateImg, 0, ...
+                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Unerwartetes Token "source-over\'\r\n      ctx.drawImage(this.templateImg, 0, 0)\r\n    } else {\r\n      ctx.globalCompositeOperation = \'source-over\'\r\n    }\r\n\r\n    // Create and draw gradient\r\n    const gradient = this.createGradient(ctx, canvas, 
gradientColors, gradDirection)\r\n    ctx.globalCompositeOperation = \'source-atop\'\r\n    ctx.fillStyle = gradient\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n\r\n    // Draw template on top\r\n    if (this.templateReady && this.templateImg) {\r\n    
  ctx.globalCompositeOperation = \'destination-over\'\r\n      ctx.drawImage(this.templateImg, 0, 0)\r\n    }\r\n\r\n    ctx.globalCompositeOperation = \'source-over\'\r\n\r\n    // Draw user images\r\n    if (frontImage) {\r\n      ctx.drawImage(frontImage, 
this.FRONT_X, this.FRONT_Y, this.FRONT_W, this.FRONT_H)\r\n    }'" in Ausdruck oder Anweisung.
In Zeile:1 Zeichen:1120
+ ... FRONT_X, this.FRONT_Y, this.FRONT_W, this.FRONT_H)\r\n    }', '    // ...
+                                                                 ~
Argument in der Parameterliste fehlt.
In Zeile:1 Zeichen:1470
+ ... n page load.\r\n    const gradient = this.createGradient(ctx, canvas, ...
+                                                                 ~
Argument in der Parameterliste fehlt.
In Zeile:1 Zeichen:1545
+ ... ntColors, gradDirection)\r\n\r\n    if (this.templateReady && this.te ...
+                                                                ~~
Das Token "&&" ist in dieser Version kein gültiges Anweisungstrennzeichen.
In Zeile:1 Zeichen:1751
+ ... on = \'source-over\'\r\n      ctx.drawImage(this.templateImg, 0, 0)\r ...
+                                                                 ~
Argument in der Parameterliste fehlt.
In Zeile:1 Zeichen:1880
+ ... r\n      ctx.fillStyle = gradient\r\n      ctx.fillRect(0, 0, canvas. ...
+                                                                  ~
Ausdruck nach "," fehlt.
In Zeile:1 Zeichen:1881
+ ... fillStyle = gradient\r\n      ctx.fillRect(0, 0, canvas.width, canvas ...
+                                                      ~~~~~~~~~~~~
Unerwartetes Token "canvas.width" in Ausdruck oder Anweisung.
In Zeile:1 Zeichen:1880
+ ... r\n      ctx.fillStyle = gradient\r\n      ctx.fillRect(0, 0, canvas. ...
+                                                                  ~
Schließende ")" fehlt in einem Ausdruck.
In Zeile:1 Zeichen:1566
+ ... ion)\r\n\r\n    if (this.templateReady && this.templateImg) {\r\n     ...
+                                                                 ~
Die schließende "}" fehlt im Anweisungsblock oder der Typdefinition.
Es wurden nicht alle Analysefehler berichtet. Korrigieren Sie die berichteten Fehler, und versuchen Sie es erneut.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : MissingEndParenthesisInMethodCall
 

